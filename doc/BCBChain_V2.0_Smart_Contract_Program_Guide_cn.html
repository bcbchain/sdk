<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>BCBChain_V2.0_Smart_Contract_Program_Guide_cn</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 0px 2px; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }





 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h1><a name='header-n0' class='md-header-anchor '></a>BCBChain V2.0 Smart Contract Program Guide</h1><p><strong>V2.0.4</strong></p><div style="page-break-after: always;"></div><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n0"><a class="md-toc-inner" href="#header-n0">BCBChain V2.0 Smart Contract Program Guide</a></span><span class="md-toc-item md-toc-h1" data-ref="n8"><a class="md-toc-inner" href="#header-n8">1 什么是BCBChain</a></span><span class="md-toc-item md-toc-h1" data-ref="n14"><a class="md-toc-inner" href="#header-n14">2 智能合约概述</a></span><span class="md-toc-item md-toc-h2" data-ref="n17"><a class="md-toc-inner" href="#header-n17">2.1 简单的智能合约</a></span><span class="md-toc-item md-toc-h3" data-ref="n18"><a class="md-toc-inner" href="#header-n18">2.1.1 存储</a></span><span class="md-toc-item md-toc-h3" data-ref="n95"><a class="md-toc-inner" href="#header-n95">2.1.2 代币</a></span><span class="md-toc-item md-toc-h2" data-ref="n156"><a class="md-toc-inner" href="#header-n156">2.2 区块链基础</a></span><span class="md-toc-item md-toc-h3" data-ref="n158"><a class="md-toc-inner" href="#header-n158">2.2.1 交易/事务</a></span><span class="md-toc-item md-toc-h3" data-ref="n164"><a class="md-toc-inner" href="#header-n164">2.2.2 状态</a></span><span class="md-toc-item md-toc-h3" data-ref="n172"><a class="md-toc-inner" href="#header-n172">2.2.3 区块</a></span><span class="md-toc-item md-toc-h3" data-ref="n178"><a class="md-toc-inner" href="#header-n178">2.2.4 调用</a></span><span class="md-toc-item md-toc-h3" data-ref="n185"><a class="md-toc-inner" href="#header-n185">2.2.3 收据</a></span><span class="md-toc-item md-toc-h1" data-ref="n189"><a class="md-toc-inner" href="#header-n189">3 智能合约编程实例</a></span><span class="md-toc-item md-toc-h2" data-ref="n190"><a class="md-toc-inner" href="#header-n190">3.1 委托投票</a></span><span class="md-toc-item md-toc-h2" data-ref="n202"><a class="md-toc-inner" href="#header-n202">3.2 慈善捐款</a></span><span class="md-toc-item md-toc-h1" data-ref="n207"><a class="md-toc-inner" href="#header-n207">4 深入理解智能合约</a></span><span class="md-toc-item md-toc-h2" data-ref="n208"><a class="md-toc-inner" href="#header-n208">4.1 组织机构</a></span><span class="md-toc-item md-toc-h2" data-ref="n214"><a class="md-toc-inner" href="#header-n214">4.2 BNF范式</a></span><span class="md-toc-item md-toc-h2" data-ref="n228"><a class="md-toc-inner" href="#header-n228">4.3 合约标记</a></span><span class="md-toc-item md-toc-h3" data-ref="n231"><a class="md-toc-inner" href="#header-n231">4.3.1 contract</a></span><span class="md-toc-item md-toc-h3" data-ref="n240"><a class="md-toc-inner" href="#header-n240">4.3.2 version</a></span><span class="md-toc-item md-toc-h3" data-ref="n249"><a class="md-toc-inner" href="#header-n249">4.3.3 organization</a></span><span class="md-toc-item md-toc-h3" data-ref="n257"><a class="md-toc-inner" href="#header-n257">4.3.4 author</a></span><span class="md-toc-item md-toc-h3" data-ref="n266"><a class="md-toc-inner" href="#header-n266">4.3.5 constructor</a></span><span class="md-toc-item md-toc-h3" data-ref="n275"><a class="md-toc-inner" href="#header-n275">4.3.6 public:store</a></span><span class="md-toc-item md-toc-h3" data-ref="n286"><a class="md-toc-inner" href="#header-n286">4.3.7 public:store:cache</a></span><span class="md-toc-item md-toc-h3" data-ref="n297"><a class="md-toc-inner" href="#header-n297">4.3.8 public:receipt</a></span><span class="md-toc-item md-toc-h3" data-ref="n308"><a class="md-toc-inner" href="#header-n308">4.3.9 public:method</a></span><span class="md-toc-item md-toc-h3" data-ref="n325"><a class="md-toc-inner" href="#header-n325">4.3.10 public:interface</a></span><span class="md-toc-item md-toc-h3" data-ref="n340"><a class="md-toc-inner" href="#header-n340">4.3.11 public:mine</a></span><span class="md-toc-item md-toc-h3" data-ref="n354"><a class="md-toc-inner" href="#header-n354">4.3.12 import</a></span><span class="md-toc-item md-toc-h2" data-ref="n373"><a class="md-toc-inner" href="#header-n373">4.4 合约规范</a></span><span class="md-toc-item md-toc-h3" data-ref="n374"><a class="md-toc-inner" href="#header-n374">4.4.1 BNF范式定义</a></span><span class="md-toc-item md-toc-h3" data-ref="n378"><a class="md-toc-inner" href="#header-n378">4.4.2 包结构规范</a></span><span class="md-toc-item md-toc-h3" data-ref="n383"><a class="md-toc-inner" href="#header-n383">4.4.3 白名单列表</a></span><span class="md-toc-item md-toc-h2" data-ref="n391"><a class="md-toc-inner" href="#header-n391">4.5 BRC20代币</a></span><span class="md-toc-item md-toc-h3" data-ref="n405"><a class="md-toc-inner" href="#header-n405">4.5.1 Transfer</a></span><span class="md-toc-item md-toc-h3" data-ref="n440"><a class="md-toc-inner" href="#header-n440">4.5.2 AddSupply</a></span><span class="md-toc-item md-toc-h3" data-ref="n470"><a class="md-toc-inner" href="#header-n470">4.5.3 Burn</a></span><span class="md-toc-item md-toc-h3" data-ref="n500"><a class="md-toc-inner" href="#header-n500">4.5.4 SetGasPrice</a></span><span class="md-toc-item md-toc-h3" data-ref="n527"><a class="md-toc-inner" href="#header-n527">4.5.6 SetOwner</a></span><span class="md-toc-item md-toc-h1" data-ref="n557"><a class="md-toc-inner" href="#header-n557">5 开发智能合约</a></span></p></div><script src="./github/ltview.js"></script>
<div style="page-break-after: always;"></div><h1><a name='header-n8' class='md-header-anchor '></a>1 什么是BCBChain</h1><p>BCBChain是以Tendermint为基础开发的区块链体系，以系统安全性为依归，进行技术创新，实现物与物、人与物之间高效的价值信息传递，打造快速应用，具备高性能及高扩展性的平台。</p><p>更详细的介绍参见《BCBChain_V2.0_Program_Reference》。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h1><a name='header-n14' class='md-header-anchor '></a>2 智能合约概述</h1><p>BCBChain从V2.0版开始支持独立开发与部署智能合约，智能合约采用golang进行开发。</p><p>&nbsp;</p><h2><a name='header-n17' class='md-header-anchor '></a>2.1 简单的智能合约</h2><h3><a name='header-n18' class='md-header-anchor '></a>2.1.1 存储</h3><p>让我们先看一个最简单的智能合约。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n20" mdtype="fences" style="break-inside: unset;">package mystorage

import (
	"blockchain/smcsdk/sdk"
)

//MyStorage a demo contract
//@:contract:mystorage
//@:version:1.0
//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer
//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c
type MyStorage struct {
	sdk sdk.ISmartContract

	//@:public:store
	storedData uint64
}

//InitChain init when deployed on the blockchain first time
//@:constructor
func (ms *MyStorage) InitChain() {
}

//Set set a data to the stored data
//@:public:method:gas[100]
func (ms *MyStorage) Set(data uint64) {
	ms._setStoredData(data)
}

//Get get the stored data
//@:public:method:gas[100]
func (ms *MyStorage) Get() uint64 {
	return ms._storedData()
}
</pre><p>BCBChain的智能合约就是一组代码（合约的函数）和数据（合约的状态数据）以及一组标记（合约的元数据），它位于BCBChain的一个特定地址上。</p><p>&nbsp;</p><p>代码行：</p><p><code>package mystorage</code></p><p>声明智能合约代码包的名称，开发者可以自由设定，只需要符合 golang 标准即可。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n28" mdtype="fences">import (
	"blockchain/smcsdk/sdk"
)
</pre><p>声明智能合约需要引入的代码包，上述代码引入了BCBChain发布的智能合约SDK的相关代码包，在开发智能合约时需要在 GOPATH 中配置智能合约SDK的路径。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n32" mdtype="fences">//MyStorage a demo contract
//@:contract:mystorage
//@:version:1.0
//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer
//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c
type MyStorage struct {
	sdk sdk.ISmartContract

	//@:public:store
	storedData uint64
}
</pre><p>声明智能合约的元数据以及状态数据。</p><ul><li>注释行  <code>//MyStorage a demo contract</code>  对下面定义的合约进行注释。</li><li>标记行  <code>//@:contract:mystorage</code>  声明下面定义的数据结构  <code>MyStorage</code>  代表一个智能合约，同时声明该智能合约的名称为  <code>mystorage</code>，合约名称是将智能合约代码部署到BCBChain主链上的时候需要提供的名称，同一个组织开发的不同智能合约的合约名称不能相同，请智能合约的开发者进行合理的规划。</li><li>标记行  <code>//@:version:1.0</code>  声明智能合约的代码版本。</li><li>标记行  <code>//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer</code>  标识智能合约所属的组织，示例中的组织对应的组织名称为：<code>example</code>。</li><li>标记行  <code>//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c</code>  标识智能合约的开发者公钥。
代码行  <code>type MyStorage struct {</code>  声明智能合约的数据结构开始，智能合约的函数与状态数据都是该数据结构下的成员。代码行  <code>sdk sdk.ISmartContract</code>  表示该数据结构是遵循BCBChain智能合约SDK的智能合约，将自动聚合SDK提供的智能合约访问上下文（变量名必须定义为sdk）。</li><li>标记行  <code>//@:public:store</code>  表示下一行代码将声明一个状态数据。</li><li>代码行  <code>storedData uint64</code>  声明一个类型为<code>uint64</code>的状态变量，变量名为<code>storedData</code>，你可以认为它是状态数据库里的一个位置，可以通过调用管理数据库的函数进行查询和变更，从外部访问状态数据库中的这个变量的KEY值为<code>/orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer/mystorage/storedData</code>。BCBChain提供的辅助工具将会为该状态变量自动封装并生成访问函数<code>_storeData() uint64</code>、<code>_setStoreData(uint64)</code>、<code>_chkStoreData() bool</code>和<code>_delStoreData() bool</code>。</li><li>代码行  <code>}</code>  表示智能合约数据结构定义完成。</li></ul><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n53" mdtype="fences">//InitChain init when deployed on the blockchain first time
//@:constructor
func (ms *MyStorage) InitChain() {
}
</pre><p>声明智能合约的上链初始化代码（只在第一次部署时执行，升级合约时将执行另一个初始化代码 <code>UpdateChain</code>，在本合约中不需要定义）。</p><ul><li>标记行  <code>//@:constructor</code>  声明下面定义的函数 <code>InitChain()</code> 是一个智能合约的标准区块链初始化函数，在BCBChain上第一次部署这个合约的时候自动进行唯一一次调用，以完成智能合约在区块链上的初始化工作，例如初始化某些全局状态变量的初始值。</li><li>代码行  <code>func (ms *MyStorage) InitChain() {</code>  声明智能合约上链初始化的函数原型，函数名必须为<code>InitChain</code>，该函数没有输入参数。</li><li>代码行  <code>}</code>  表示智能合约上链初始化的函数实现完成。</li></ul><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n64" mdtype="fences">//Set set a data to the stored data
//@:public:method:gas[100]
func (ms *MyStorage) Set(data uint64) {
	ms._setStoredData(data)
}
</pre><p>声明智能合约的代码。</p><ul><li>标记行  <code>//@:public:method:gas[100]</code>  声明下面定义的函数 <code>Set()</code> 是一个智能合约的公共函数，可以通过BCBChain交易广播的方式进行调用，并将调用信息及结果记录在区块链上，同时声明对该函数的调用将消耗的燃料为100。</li><li>代码行  <code>func (ms *MyStorage) Set(data uint64) {</code>  声明一个智能合约的函数原型。代码行  <code>ms._setStoredData(data)</code>  为该函数的实现代码，表示将输入的参数保存到状态变量<code>storedData</code>中。</li><li>代码行  <code>}</code>  表示智能合约函数实现完成。</li></ul><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n75" mdtype="fences">//Get get the stored data
//@:public:method:gas[100]
func (ms *MyStorage) Get() uint64 {
	return ms._storedData()
}
</pre><p>声明智能合约的代码。</p><ul><li>标记行  <code>//@:public:method:gas[100]</code>  声明下面定义的函数  <code>Get()</code>  是一个智能合约的公共函数，可以通过BCBChain交易广播的方式进行调用，并将调用信息及结果记录在区块链上，同时声明对该函数的调用将消耗的燃料为100。</li><li>代码行  <code>func (ms *MyStorage) Get() uint64 {</code>  声明一个智能合约的函数原型。代码行  <code>return ms._storedData()</code>  为该函数的实现代码，表示将读取状态变量<code>storedData</code>的值并返回给调用者。</li><li>代码行  <code>}</code>  表示智能合约函数实现完成。</li></ul><p>&nbsp;</p><p>该合约能完成的事情并不多：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 Set ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。</p><p>&nbsp;</p><p>备注：</p><ul><li>智能合约代码所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。</li><li>智能合约代码要求使用ASSCII或UTF-8编码的形式存储。</li></ul><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n95' class='md-header-anchor '></a>2.1.2 代币</h3><p>下面的合约实现了一个最简单的加密代币。在这里，代币确实可以无中生有地产生，但是只有合约的拥有者才能做到，而且，任何人都可以给其他人转币，不需要注册用户名和密码 —— 所需要的只是符合 BCBChain 规范的密钥对。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n97" mdtype="fences" style="break-inside: unset;">package mycoin

import (
	"blockchain/smcsdk/sdk"
	"blockchain/smcsdk/sdk/bn"
	"blockchain/smcsdk/sdk/types"
)

//Mycoin a demo contract for digital coin
//@:contract:mycoin
//@:version:1.0
//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer
//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c
type Mycoin struct {
	sdk sdk.ISmartContract

	//@:public:store:cache
	totalSupply bn.Number

	//@:public:store
	balanceOf map[types.Address]bn.Number
}

const oneToken int64 = 1000000000

//InitChain init when deployed on the blockchain first time
//@:constructor
func (mc *Mycoin) InitChain() {
  thisContract := mc.sdk.Helper().ContractHelper().ContractOfName("mycoin")
  totalSupply := bn.N1(1000000, oneToken)
  mc._setTotalSupply(totalSupply)
  mc._setBalanceOf(thisContract.Owner().Address(), totalSupply)
}

//@:public:receipt
type receipt interface {
	emitTransferMyCoin(token, from, to types.Address, value bn.Number)
}

//Transfer transfer coins from sender to another
//@:public:method:gas[500]
//@:public:interface:gas[450]
func (mc *Mycoin) Transfer(to types.Address, value bn.Number) {
	sdk.Require(value.IsPositive(),
		types.ErrInvalidParameter, "value must be positive")

	sender := mc.sdk.Message().Sender().Address()
	newBalanceOfSender := mc._balanceOf(sender).Sub(value)
	sdk.Require(newBalanceOfSender.IsGEI(0),
		types.ErrInsufficientBalance, "")

	receiver := to
	newBalanceOfReceiver := mc._balanceOf(receiver).Add(value)

	mc._setBalanceOf(sender, newBalanceOfSender)
	mc._setBalanceOf(receiver, newBalanceOfReceiver)

	mc.emitTransferMyCoin(
		mc.sdk.Message().Contract().Address(),
		sender,
		receiver,
		value)
}
</pre><p>这个合约引入了一些新的概念，下面逐一解读。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n101" mdtype="fences">	//@:public:store:cache
	totalSupply bn.Number
</pre><p>声明智能合约的状态数据。</p><ul><li>标记行  <code>//@:public:store:cache</code>  表示下一行代码将声明一个状态数据，该状态数据将会在内存中进行缓存。</li><li>代码行  <code>totalSupply bn.Number</code>  声明一个类型为<code>bn.Number</code>的状态变量，变量名为<code>totalSupply</code>，<code>bn.Number</code>类型表示一个带符号的大数，进行加减乘除操作时不必考虑溢出的问题，从外部访问状态数据库中的这个变量的KEY值为<code>/orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer/mycoin/totalSupply</code>。BCBChain提供的辅助工具将会为该变量自动封装并生成访问函数<code>_totalSupply() bn.Number</code>、<code>_setTotalSupply(bn.Number)</code>、<code>_chkTotalSupply() bool</code>和<code>_delTotalSupply()</code>，由于标记<code>cache</code>的影响，还会生成一个清除内存缓存的函数<code>_clrTotalSupply()</code>。</li></ul><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n110" mdtype="fences">	//@:public:store
	balanceOf map[types.Address]bn.Number
</pre><p>也声明了一个公共状态变量，但它是一个更复杂的数据类型。 该类型将地址映射为大数，用于存储拥有该种代币的账户地址对应的余额。 从外部访问状态数据库中的这个变量的KEY值为<code>/orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer/mycoin/balanceOf/address</code>，其中<code>address</code>为实际要查询的账户地址。BCBChain提供的辅助工具将会为该变量自动封装并生成访问函数<code>_balanceOf(types.Address) bn.Number</code>、<code>_setBalanceOf(types.Address, bn.Number)</code>、<code>_chkBalanceOf(types.Address) bool</code>和<code>_delBalanceOf(types.Address)</code>。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n114" mdtype="fences">//@:public:receipt
type receipt interface {
	emitTransferMyCoin(token, from, to types.Address, value bn.Number)
}
</pre><p>声明智能合约方法执行时发送的收据，收据将会被保存在BCBChain链中供人们查询。</p><ul><li>标记行  <code>//@:public:receipt</code>  声明下一行代码为收据接口定义。</li><li>代码行  <code>type receipt interface {</code>  声明实际的收据接口类型开始，类型名称固定为 <code>receipt</code>  。</li><li>代码行  <code>emitTransferMyCoin(token, from, to types.Address, value bn.Number)</code>  声明了一个所谓的收据（receipt），它会在 Transfer函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听BCBChain链上正在发送的收据，而不会花费太多成本。一旦它被发出，监听该收据的<code>listener</code>都将收到通知，可方便追踪交易。</li><li>代码行  <code>}</code>  表示收据接口定义完成。</li></ul><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n127" mdtype="fences">//Transfer transfer coins from sender to another
//@:public:method:gas[500]
//@:public:interface:gas[450]
func (mc *Mycoin) Transfer(to types.Address, value bn.Number) {
    .
    .
    .
}
</pre><p>声明智能合约的代码。</p><ul><li>标记行  <code>//@:public:interface:gas[450]</code>  声明下面定义的函数  <code>Transfer()</code>  是一个智能合约的公共接口，可以通过智能合约之间相互进行跨合约调用的机制进行调用，并将调用信息及结果记录在BCBChain链上。同一组织在BCBChain上部署的智能合约之间可以进行相互调用，BCBChain基础组织部署的智能合约所提供的公共接口可以由任意智能合约进行调用。</li></ul><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n134" mdtype="fences">  sdk.RequireAddress(to)
  sdk.Require(value.IsPositive(),
		types.ErrInvalidParameter, "value must be positive")
</pre><p>声明一段合约代码逻辑。函数 <code>sdk.RequireAddress()</code>  由SDK提供用于检测输入参数<code>to</code>是否是一个标准的账户地址，如果不满足则自动结束合约的执行，并返回相应的错误信息。函数 <code>sdk.Require()</code>  由SDK提供，用于检测某个条件必须成立(此处是检测输入参数<code>value</code>必须大于0)，否则自动结束合约的执行，并返回相应的错误信息。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n138" mdtype="fences">  sender := mc.sdk.Message().Sender().Address()
  newBalanceOfSender := mc._balanceOf(sender).Sub(value)
  sdk.Require(newBalanceOfSender.IsGEI(0),
		types.ErrInsufficientBalance, "")
</pre><p>声明一段合约代码逻辑。函数 <code>mc.sdk.Message().Sender().Address()</code> 由SDK提供，用于获取消息发起者的账户地址。<code>mc._balanceOf(sender).Sub(value)</code> 用于获取消息发起者账户地址所拥有代币的余额并减去转账金额，计算出新的账户余额，函数<code>_balanceOf()</code>是由BCBChain提供的辅助工具自动生成的。函数 <code>sdk.Require()</code>  由SDK提供，用于检测某个条件必须成立(此处是检测转账发起者的余额足够进行转账操作)，否则自动结束合约的执行，并返回相应的错误信息。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n142" mdtype="fences">  receiver := to
  newBalanceOfReceiver := mc._balanceOf(receiver).Add(value)
</pre><p>声明一段合约代码逻辑。<code>mc._balanceOf(receiver).Add(value)</code> 用于计算接收转账的账户地址所拥有的新的账户余额。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n146" mdtype="fences">  mc._setBalanceOf(sender, newBalanceOfSender)
  mc._setBalanceOf(receiver, newBalanceOfReceiver)
</pre><p>声明一段合约代码逻辑。用于将计算得出的新的账户余额写入状态数据库中，函数<code>_setBalanceOf()</code>是由BCBChain提供的辅助工具自动生成的。</p><p>&nbsp;</p><p>代码段：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n150" mdtype="fences">  mc.emitTransferMyCoin(
		mc.sdk.Message().Contract().Address(),
		sender,
		receiver,
		value)
</pre><p>声明一段合约代码逻辑。用于向区块链发送本次转账的收据，函数<code>emitTransferMyCoin()</code>是由BCBChain提供的辅助工具自动生成的。</p><p>&nbsp;</p><p>这个合约提供了两个函数，函数 <code>InitChain()</code>是在部署合约之后由BCBChain链自动调用一次，用于对合约进行初始化。 真正被用户或其他合约所调用的，以完成本合约功能的函数是<code>Transfer()</code>。 函数<code>Transfer()</code>可被任何人用于向他人发送代币 (当然，前提是发送者拥有这些代币)。记住，如果你使用合约发送代币给一个地址，当你在BCBChain链浏览器上查看该地址时是看不到任何相关信息的。因为，实际上你发送代币和更改余额的信息仅仅存储在这个合约的数据存储器中（需要使用特殊的查询手段从状态数据库进行查询）。通过使用收据，你可以非常简单地为你的新代币创建一个“区块链浏览器”来追踪交易和余额。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h2><a name='header-n156' class='md-header-anchor '></a>2.2 区块链基础</h2><p>程序员对于区块链这个概念应该并不难理解，这是因为大多数复杂的算法与协议 (哈希 ，椭圆曲线密码学 ，点对点网络（P2P） 等) 都只是用于提供特定的功能和承诺。对于智能合约开发程序员来说，只需接受这些既有的特性与功能，不必关心底层技术的实现方案。</p><h3><a name='header-n158' class='md-header-anchor '></a>2.2.1 交易/事务</h3><p>区块链是一种全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务（在区块链世界又被称为交易）。事务一词意味着你想做的（假设您想要同时更改两个值），要么一点没做，要么全部完成。此外，当你的事务被应用到数据库时，其他事务不能修改数据库。</p><p>举个例子，设想一张表，列出电子货币中所有账户的余额。如果你请求从一个账户转移到另一个账户，数据库的事务特性确保了如果从一个账户扣除金额，它总被添加到另一个账户。如果由于某些原因，无法添加金额到目标账户时，源账户也不会发生任何变化。</p><p>此外，交易总是由发送人（创建者）签名。这样，就可非常简单地为数据库的特定修改增加访问保护机制。在数字代币的例子中，一个简单的检查可以确保只有持有账户密钥的人才能从中转账。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n164' class='md-header-anchor '></a>2.2.2 状态</h3><p>BCBChain参考了Ethereum、Fabric、Tendermint、Cosmos等开源区块链方案，借鉴了其中一些优秀思想。</p><p>BCBChain在本质上是一个基于交易的状态机(transaction-based state machine)。在计算机科学中，状态机是一个包含一组状态集（states）、一个起始状态（start state）、一组输入符号集（alphabet）、一个映射输入符号和当前状态到下一状态的转换函数（transition function）的计算模型。</p><p>在BCBChain其中状态集由状态数据库进行表达，起始状态被称为创世状态（genesis state），输入的符号集就是在区块链领域常说的交易（transaction，简称tx），状态转换函数就是智能合约。</p><p><img src='./p/statemachine.png' alt='' referrerPolicy='no-referrer' /></p><p>根据BCBChain的状态机，我们从创世状态(genesis state)开始。这差不多类似于一片空白的石板，在网络中还没有任何交易产生的状态。当交易被执行后，这个创世纪状态就会转变成最终状态。在任何时刻，这个最终状态都代表着BCBChain当前的状态。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n172' class='md-header-anchor '></a>2.2.3 区块</h3><p>BCBChain的状态由成千上万个交易达成。这些交易都被 “组团” 到一个个区块中。一个区块包含了一系列的交易，每个区块都与它的前一个区块链接起来，这正是“区块链”这个词的来源，每一个区块都会导致状态机达到一个新的状态。</p><p><img src='./p/blockchain.png' alt='' referrerPolicy='no-referrer' /></p><p>为了让一个状态转换成下一个状态，交易必须是有效的（也就是促使采用区块链技术的不可抵赖特性需求）。为了让一个交易被认为是有效的，它必须要经过一个验证过程，每一个交易都必须由交易发起人通过自己的私钥进行签名，并且在BCBChain的智能合约中校验满足一定的条件，才能被认为是有效的。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n178' class='md-header-anchor '></a>2.2.4 调用</h3><p>智能合约可以通过消息调用的方式来调用其它智能合约。</p><p>每个交易都可以包含多个按顺序执行的顶层消息调用，前一个消息调用的输出收据可以作为下一个顶层消息调用的</p><p>输入，在下一个顶层消息调用中执行一些逻辑处理代码。每一个顶层消息调用，这个消息调用会依次产生更多的跨合约的消息调用。</p><p>消息调用层数被限制为8层，为了预防死循环，各层消息调用不能形成环路。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n185' class='md-header-anchor '></a>2.2.3 收据</h3><p>每一个消息调用除了返回结果以外，还可以返回执行合约业务逻辑过程中的日志数据，在这里我们把它称为收据，这些收据数据保存在区块上，可以很方便的进行检索。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h1><a name='header-n189' class='md-header-anchor '></a>3 智能合约编程实例</h1><h2><a name='header-n190' class='md-header-anchor '></a>3.1 委托投票</h2><p>以下的合约相当复杂，它实现了一个委托投票合约。 当然，电子投票的主要问题是如何将投票权分配给正确的人员以及如何防止被操纵。 我们不会在这里解决所有的问题，但至少我们会展示如何进行委托投票，同时，计票又是自动和完全透明的 。</p><p>我们的想法是为每个（投票）表决创建一份合约，为每个选项提供简称。 然后作为合约的创造者——即主席，将给予每个独立的地址以投票权。</p><p>地址后面的人可以选择自己投票，或者委托给他们信任的人来投票。</p><p>在投票时间结束时，<code>WinningProposal()</code>将返回获得最多投票的提案。</p><p>这个合约实现采用了两个文件，分别如下：</p><p><code>myballot_types.go</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n197" mdtype="fences" style="break-inside: unset;">package myballot

import (
	"blockchain/smcsdk/sdk/types"
)

// Voter this declares a new complex type which will
//       be used for variables later.
//       it will represent a single voter.
type Voter struct {
	weight   uint          // weight is accumulated by delegation
	voted    bool          // if true, that person already voted
	delegate types.Address // person delegated to
	vote     uint          // index of the voted proposal
}

//Proposal this is a type for a single proposal.
type Proposal struct {
	name      string // short name (up to 32 bytes)
	voteCount uint   // number of accumulated votes
}
</pre><p><code>myballot.go</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n199" mdtype="fences" style="break-inside: unset;">package myballot

import (
	"blockchain/smcsdk/sdk"
	"blockchain/smcsdk/sdk/forx"
	"blockchain/smcsdk/sdk/types"
)

//Ballot a demo smart contract for voting with delegation.
//@:contract:myballot
//@:version:1.0
//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer
//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c
type Ballot struct {
	sdk sdk.ISmartContract

	//chairperson this declares a state variable that stores a chairperson's 
	//            address for the contract
	//@:public:store:cache
	chairperson string

	//voters this declares a state variable that stores a 'Voter' struct for
	//       each possible address
	//@:public:store
	voters map[types.Address]Voter

	//proposals a dynamically-sized array of 'Proposal' structs
	//@:public:store:cache
	proposals []Proposal
}

//InitChain init when deployed on the blockChain first time
//@:constructor
func (ballot *Ballot) InitChain() {
}

//Init create a new (voting) vote for each proposal in 'proposal Names'
//@:public:method:gas[500]
func (ballot *Ballot) Init(proposalNames []string) {
	sender := ballot.sdk.Message().Sender().Address()

	// Only cntract's owner can perform init
	sdk.RequireOwner()

	proposals := ballot._proposals()
	sdk.Require(len(proposals) &lt;= 0,
		types.ErrUserDefined, "Already inited")

	chairperson := sender
	ballot._setChairperson(chairperson)

	voter := ballot._voters(chairperson)
	voter.weight = 1
	ballot._setVoters(chairperson, voter)

	// For each of the provided proposal names,
	// create a new 'Proposal' object and add it to the end of the array
	forx.Range(proposalNames, func(i int, pName string) {
		proposals = append(proposals,
			Proposal{
				name:      pName,
				voteCount: 0,
			})
	})
	ballot._setProposals(proposals)
}

//GiveRightToVote give `voter` the right to vote on this ballot.
//                may only be called by 'chairperson'.
//@:public:method:gas[500]
func (ballot *Ballot) GiveRightToVote(voterAddr types.Address) {
	sender := ballot.sdk.Message().Sender().Address()
	chairperson := ballot._chairperson()
	sdk.Require(sender == chairperson,
		types.ErrNoAuthorization, "Only chairperson can give right to vote.")

	voter := ballot._voters(voterAddr)
	sdk.Require(voter.voted == false,
		types.ErrUserDefined, "The voter already voted.")
	sdk.Require(voter.weight == 0,
		types.ErrUserDefined, "The voter's weight must be zero.")

	voter.weight = 1
	ballot._setVoters(voterAddr, voter)
}

//Delegate Delegate your vote to the voter 'to'
//@:public:method:gas[1500]
func (ballot *Ballot) Delegate(to types.Address) {
	sender := ballot.sdk.Message().Sender().Address()
	sendVoter := ballot._voters(sender)
	
	sdk.Require(sendVoter.voted == false,
		types.ErrUserDefined, "You already voted.")
	sdk.Require(to != sender,
		types.ErrUserDefined, "Self-delegation is disallowed.")

  // Forward the delegation as long as 'to' also delegated.
  // In general, such loops are very dangerous, because if they run too 
  // long, they might need more gas than is available in a block.
  // In this case, the delegation will not be executed, but in other 
  // situations, such loops might cause a contract to get "stuck" completely.
	toVoter := ballot._voters(to)
	forx.Range( func() bool {
	              return toVoter.delegate != ""
	            },
	            func(i int) {
							  to = toVoter.delegate
							  toVoter = ballot._voters(to)
					
							  // We found a loop in the delegation, not allowed.
							  sdk.Require(to != sender,
								  types.ErrUserDefined, "Found loop in delegation.")
						  })

	sendVoter.voted = true
	sendVoter.delegate = to
	delegate := toVoter
	if delegate.voted {
    // If the delegate already voted,
    // directly add to the number of votes
		proposals := ballot._proposals()
		proposals[int(delegate.vote)].voteCount += sendVoter.weight
		ballot._setProposals(proposals)
	} else {
    // If the delegate did not vote yet,
    // add to her weight.
		delegate.weight += sendVoter.weight
		ballot._setVoters(to, delegate)
	}
	return
}

//Vote give your vote (including votes delegated to you)
//     to proposal `proposals[proposal].name`.
//@:public:method:gas[500]
func (ballot *Ballot) Vote(proposal uint) {
	sender := ballot.sdk.Message().Sender().Address()
	sendVoter := ballot._voters(sender)
	
	sdk.Require(sendVoter.voted == false,
		types.ErrUserDefined, "You already voted.")

	proposals := ballot._proposals()
	sdk.Require(proposal &lt; uint(len(proposals)),
		types.ErrUserDefined, "Proposal is out of index.")

	sendVoter.voted = true
	sendVoter.vote = proposal
	proposals[int(proposal)].voteCount += sendVoter.weight
	ballot._setProposals(proposals)
}

//WinningProposal computes the winning proposal taking all
//                previous votes into account.
//@:public:method:gas[500]
func (ballot *Ballot) WinningProposal() (winningProposal uint) {
	var winningVoteCount uint
	
	proposals := ballot._proposals()
	forx.Range(proposals, func(i int, proposal Proposal) {
		if proposal.voteCount &gt; winningVoteCount {
			winningVoteCount = proposal.voteCount
			winningProposal = uint(i)
		}
	})
	return
}

//WinnerName calls winningProposal() function to get the index
//           of the winner contained in the proposals array and then
//           returns the name of the winner
//@:public:method:gas[500]
func (ballot *Ballot) WinnerName() (winnerName string) {
	proposals := ballot._proposals()
	if len(proposals) &gt; 0 {
		winnerName = proposals[ballot.WinningProposal()].name
	}
	return
}
</pre><p>&nbsp;</p><div style="page-break-after: always;"></div><h2><a name='header-n202' class='md-header-anchor '></a>3.2 慈善捐款</h2><p>以下的合约实现了一个简单的慈善捐款功能。 合约代码如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n204" mdtype="fences" style="break-inside: unset;">package mydonation

import (
	"blockchain/smcsdk/sdk"
	"blockchain/smcsdk/sdk/bn"
	"blockchain/smcsdk/sdk/forx"
	"blockchain/smcsdk/sdk/std"
	"blockchain/smcsdk/sdk/types"
)

//Mydonation This is struct of contract
//@:contract:mydonation
//@:version:1.0
//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer
//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c
type Mydonation struct {
	sdk sdk.ISmartContract

	//Total donations received by donees
	//@:public:store
	donations map[types.Address]bn.Number // key=address of donee
}

const (
	errDoneeCannotBeOwner = 55000 + iota
	errDoneeCannotBeSmc
	errDoneeAlreadyExist
	errDoneeNotExist
	errDonationExist
	errDonationNotEnough
)

//@:public:receipt
type receipt interface {
	emitAddDonee(donee types.Address)
	emitDelDonee(donee types.Address)
	emitDonate(from, donee types.Address, value, balance bn.Number)
	emitTransferDonation(donee types.Address, value, balance bn.Number)
}

//InitChain Constructor of this Mydonation
//@:constructor
func (d *Mydonation) InitChain() {
}

//AddDonee Add a new donee
//@:public:method:gas[500]
func (d *Mydonation) AddDonee(donee types.Address) {
	sdk.RequireOwner()
	sdk.RequireAddress(donee)
	sdk.Require(donee != d.sdk.Message().Sender().Address(),
		errDoneeCannotBeOwner, "Donee can not be owner")
	sdk.Require(donee != d.sdk.Message().Contract().Address(),
		errDoneeCannotBeSmc, "Donee can not be this smart contract")
	sdk.Require(donee != d.sdk.Message().Contract().Account().Address(),
		errDoneeCannotBeSmc, "Donee can not be account of this smart contract")
	sdk.Require(!d._chkDonations(donee),
		errDoneeAlreadyExist, "Donee already exists")

	d._setDonations(donee, bn.N(0))

	//emit receipt
	d.emitAddDonee(donee)
}

//Donate delete a donee
//@:public:method:gas[500]
func (d *Mydonation) DelDonee(donee types.Address) {
	sdk.RequireOwner()
	sdk.RequireAddress(donee)
	sdk.Require(d._chkDonations(donee),
		errDoneeNotExist, "Donee does not exist")
	sdk.Require(d._donations(donee).IsEqualI(0),
		errDonationExist, "Donation exists")

	d._delDonations(donee)

	//emit receipt
	d.emitDelDonee(donee)
}

//Donate Charitable donors donate money to smart contract
//@:public:method:gas[500]
func (d *Mydonation) Donate(donee types.Address) {
	sdk.RequireAddress(donee)
	sdk.Require(d._chkDonations(donee),
		errDoneeNotExist, "Donee does not exist")

	var valTome *std.Transfer
	token := d.sdk.Helper().GenesisHelper().Token()
	forx.Range(d.sdk.Message().GetTransferToMe(), func(i int, receipt *std.Transfer) {
		sdk.Require(receipt.Token == token.Address(),
			types.ErrInvalidParameter, "Accept donations in genesis token only")
		sdk.Require(valTome == nil,
			types.ErrInvalidParameter, "Accept only one donation at a time")
		valTome = receipt
	})
	sdk.Require(valTome != nil,
		types.ErrInvalidParameter, "Please transfer token to me first")

	balance := d._donations(donee).Add(valTome.Value)
	d._setDonations(donee, balance)

	//emit receipt
	d.emitDonate(
		d.sdk.Message().Sender().Address(),
		donee,
		valTome.Value,
		balance,
	)
}

//Withdraw To transfer donations to donee
//@:public:method:gas[500]
func (d *Mydonation) Transfer(donee types.Address, value bn.Number) {
	sdk.RequireOwner()
	sdk.RequireAddress(donee)
	sdk.Require(d._chkDonations(donee),
		errDoneeNotExist, "Donee does not exist")
	sdk.Require(value.IsGreaterThanI(0),
		types.ErrInvalidParameter, "Parameter \"value\" must be greater than 0")
	sdk.Require(d._donations(donee).IsGE(value),
		errDonationNotEnough, "Donation is not enough")

	token := d.sdk.Helper().GenesisHelper().Token()
	account := d.sdk.Message().Contract().Account()
	account.TransferByToken(token.Address(), donee, value)
	balance := d._donations(donee).Sub(value)
	d._setDonations(donee, balance)

	//emit receipt
	d.emitTransferDonation(
		donee,
		value,
		balance,
	)
}
</pre><p>&nbsp;</p><div style="page-break-after: always;"></div><h1><a name='header-n207' class='md-header-anchor '></a>4 深入理解智能合约</h1><h2><a name='header-n208' class='md-header-anchor '></a>4.1 组织机构</h2><p>为BCBChain主链开发的智能合约按照组织的架构进行组织，为同一个组织机构开发的所有智能合约都将被集成在一个合约进程中供用户进行调用。</p><p>在一个智能合约中可以调用其它智能合约提供的接口，在那个接口对应的智能合约代码中又可以调用另一个智能合约的接口，BCBChain最多支持8级嵌套的跨合约调用，嵌套调用不允许包含环形调用结构。</p><p>BCBChain设定了一个基础组织，为该基础组织开发的智能合约将被集成到所有组织的合约进程中供用户调用，这个组织的设定主要是为了提供一些可以随时被任意组织跨合约调用执行的基础合约，例如BCBChain主链的基础通证以及代币模板合约。</p><p>&nbsp;</p><div style="page-break-after: always;"></div><h2><a name='header-n214' class='md-header-anchor '></a>4.2 BNF范式</h2><p>本章对合约规范的描述采用巴科斯(BNF)范式。</p><p>巴科斯范式的英文缩写为BNF，它是以美国人巴科斯(Backus)和丹麦人诺尔(Naur)的名字命名的一种形式化的语法表示方法，用来描述语法的一种形式体系，是一种典型的元语言。又称巴科斯-诺尔形式(Backus-Naur form)。它不仅能严格地表示语法规则，而且所描述的语法是与上下文无关的。它具有语法简单，表示明确，便于语法分析和编译的特点。</p><p>BNF范式表示语法规则的方式为：</p><ul><li>非终结符用尖括号括起。</li><li>每条规则的左部是一个非终结符，右部是由非终结符和终结符组成的一个符号串，中间一般以::=分开。</li><li>具有相同左部的规则可以共用一个左部，各右部之间以竖线“|”隔开。</li></ul><p>BNF范式中常用的元字符及其表示的意义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n226" mdtype="fences">1. 在双引号中的字符(例如"word")代表着这些字符本身。而double_quote用来代表双引号本身。 
2. 在双引号外的字(有可能有下划线)代表着语法部分。 
3. 尖括号 &lt; &gt; 内包含的为必选项。 
4. 方括号 [ ] 内包含的为可选项。 
5. 大括号 { } 内包含的为可重复0至无数次的项。 
6. 圆括号 ( ) 内包含的所有项为一组，用来控制表达式的优先级。
7. 竖线 | 表示在其左右两边任选一项，相当于"OR"的意思。 
8. ::= 是“被定义为”的意思。 
9. 空白字符 BNF范式定义中出现的空白字符间隔仅为排版需要，不作为规范的一部分。
</pre><p>&nbsp;</p><h2><a name='header-n228' class='md-header-anchor '></a>4.3 合约标记</h2><p>BCBChain智能合约代码采用标记法在合约代码的注释中对合约的元数据进行描述。</p><p>下面为BCBChain智能合约所使用的各种标记的详细语法描述。</p><h3><a name='header-n231' class='md-header-anchor '></a>4.3.1 contract</h3><p>标记<code>contract</code>用于标识合约名称，同一组织之下的合约名称必须唯一，请智能合约的开发者进行合理的规划。</p><p>标记<code>contract</code>为必须标记，但在整个合约代码中只能出现一次。</p><p>标记<code>contract</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n235" mdtype="fences">&lt;contract标记语法&gt; ::= "//@:contract:" &lt;合约名称&gt;
&lt;合约名称&gt; ::= &lt;字母&gt; | &lt;合约名称&gt; &lt;字母数字串&gt;
&lt;字母数字串&gt; ::= &lt;字母&gt; | &lt;十进制数字&gt; | &lt;字母数字串&gt; &lt;字母&gt; | &lt;字母数字串&gt; &lt;十进制数字&gt; 
&lt;字母&gt; ::= "_" | "-" | "." | &lt;小写字母&gt; | &lt;大写字母&gt; 
&lt;小写字母&gt; ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | 
              "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | 
              "y" | "z" 
&lt;大写字母&gt; ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | 
              "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | 
              "Y" | "Z" 
&lt;十进制数字&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
</pre><p>标记<code>contract</code>之后的有效代码必须紧跟一个包含<code>sdk.ISmartContract</code>成员的合约类定义，这个合约类为智能合约的上下文环境，每次针对智能合约的消息调用都会自动创建这个合约类的一个实例，在这个实例上调用智能合约的方法。智能合约对外提供的方法必须属于这个类的成员函数。类名首字母必须大写。</p><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n238" mdtype="fences">//@:contract:mycoin
type Mycoin struct {
	sdk sdk.ISmartContract

	//@:public:store:cache
	totalSupply bn.Number

	//@:public:store
	balanceOf map[types.Address]bn.Number
}
</pre><p>&nbsp;</p><h3><a name='header-n240' class='md-header-anchor '></a>4.3.2 version</h3><p>标记<code>version</code>用于标识合约的版本，在整个合约代码中只能出现一次。</p><p>标记<code>version</code>为必须标记，但在整个合约代码中只能出现一次。</p><p>标记<code>version</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n244" mdtype="fences">&lt;version标记语法&gt; ::= "//@:version:" &lt;合约版本&gt;
&lt;合约版本&gt; ::= &lt;十进制数&gt; |
              &lt;十进制数&gt; "." &lt;十进制数&gt; |
              &lt;十进制数&gt; "." &lt;十进制数&gt; "." &lt;十进制数&gt; |
              &lt;十进制数&gt; "." &lt;十进制数&gt; "." &lt;十进制数&gt; "." &lt;十进制数&gt;
&lt;十进制数&gt; ::= &lt;十进制数字&gt; | &lt;十进制数&gt; &lt;十进制数字&gt;
&lt;十进制数字&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n246" mdtype="fences">//@:version:1.0
</pre><p>注：BCBChain链不要求智能合约版本的具体规则，即合约版本既可以采用一段式（例如1、2、3），也可以采用两段式（1.0、1.1、1.2）、三段式（1.0.1、1.0.2、1.0.3）、四段式（1.0.1.102、1.0.1.103），但是同一智能合约的不同版本需要保持版本格式段数的一致性。</p><p>&nbsp;</p><h3><a name='header-n249' class='md-header-anchor '></a>4.3.3 organization</h3><p>标记<code>organization</code>用于标识合约所属组织机构的ID。</p><p>标记<code>organization</code>为必须标记，但在整个合约代码中只能出现一次。</p><p>标记<code>organization</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n253" mdtype="fences">&lt;organization标记语法&gt; ::= "//@:organization:" &lt;组织ID&gt;
&lt;组织ID&gt; ::= &lt;前缀码&gt; &lt;Base58字符串&gt;
&lt;前缀码&gt; ::= "org"
&lt;Base58字符串&gt; ::= &lt;Base58字符&gt; | &lt;Base58字符串&gt; &lt;Base58字符&gt;
&lt;Base58字符&gt; ::= &lt;十进制数字&gt; | &lt;大写字母&gt; | &lt;小写字母&gt;
&lt;十进制数字&gt; ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
&lt;大写字母&gt; ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "J" | "K" | "L" | "M" |
              "N" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" 
&lt;小写字母&gt; ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "m" |
              "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" |
              "z" 
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n255" mdtype="fences">//@:organization:orgBtjfCSPCAJ84uQWcpNr74NLMWYm5SXzer
</pre><p>&nbsp;</p><h3><a name='header-n257' class='md-header-anchor '></a>4.3.4 author</h3><p>标记<code>author</code>用于标识合约作者的账户公钥。</p><p>标记<code>author</code>为必须标记，但在整个合约代码中只能出现一次。</p><p>标记<code>author</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n261" mdtype="fences">&lt;author标记语法&gt; ::= "//@:author:" &lt;账户公钥&gt;
&lt;账户公钥&gt; ::= &lt;十六进制字符串&gt;
&lt;十六进制字符串&gt; ::= &lt;十六进制数字&gt; | &lt;十六进制字符串&gt; &lt;十六进制数字&gt;
&lt;十六进制数字&gt; ::= "0" | 1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9" |
                 "A" | "B" | "C" | "D" | "E" | "F" |
                 "a" | "b" | "c" | "d" | "e" | "f"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n263" mdtype="fences">//@:author:b37e7627431feb18123b81bcf1f41ffd37efdb90513d48ff2c7f8a0c27a9d06c
</pre><p>注：十六进制公钥字符串长度必须等于64。</p><p>&nbsp;</p><h3><a name='header-n266' class='md-header-anchor '></a>4.3.5 constructor</h3><p>标记<code>constructor</code>用于标识合约的上链初始化函数。</p><p>标记<code>constructor</code>之后的有效代码必须紧跟一个名为<code>InitChain</code> 或 <code>UpdateChain</code> 的无参数函数，该函数将在BCBChain链上第一次部署(<code>InitChain</code>)或者升级(<code>UpdateChain</code>)这个合约的时候自动进行唯一一次调用，以完成智能合约在区块链上的初始化工作，例如初始化某些全局状态数据的初始值。</p><p>标记<code>constructor</code>为可选标记，但在整个合约代码中最多只能出现两次，一次标识 <code>InitChain</code> 函数，一次标识 <code>UpdateChain</code>函数。</p><p>标记<code>constructor</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n271" mdtype="fences">&lt;author标记语法&gt; ::= "//@:constructor"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n273" mdtype="fences">//@:constructor
func (mc *Mycoin) InitChain() {
	...
}

//@:constructor
func (mc *Mycoin) UpdateChain() {
	...
}
</pre><p>&nbsp;</p><h3><a name='header-n275' class='md-header-anchor '></a>4.3.6 public:store</h3><p>标记<code>public:store</code>用于标识一个状态变量，状态变量必须是通过标记<code>contract</code>标注的合约类的成员变量。</p><p>标记<code>public:store</code>之后的有效代码必须紧跟一个成员变量的定义。</p><p>标记<code>public:store</code>为可选标记，在合约类定义中可以出现多次，每次标识一个状态变量。</p><p>标记<code>public:store</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n280" mdtype="fences">&lt;public:store标记语法&gt; ::= "//@:public:store"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n282" mdtype="fences">//@:contract:mycoin
type Mycoin struct {
	sdk sdk.ISmartContract
	...
	//@:public:store
	balanceOf map[types.Address]bn.Number
}
</pre><p>标记<code>public:store</code>标识的状态变量在合约代码中不能直接访问，根据BCBChain合约规范，BCBChain链提供的SDK配套工具会自动生成访问该状态变量的读写函数，示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n284" mdtype="fences" style="break-inside: unset;">//读取状态变量balanceOf的函数
func (mc *Mycoin) _balanceOf(k types.Address) bn.Number {
	return *mc.sdk.Helper().StateHelper().GetEx(
	    fmt.Sprintf("/balanceOf/%v", k), &amp;bn.Number{V: big.NewInt(0)}).(*bn.Number)
}

//检测状态数据balanceOf是否存在的函数
func (mc *Mycoin) _chkBalanceOf(k types.Address) bool {
	return mc.sdk.Helper().StateHelper().Check(fmt.Sprintf("/balanceOf/%v", k))
}

//设置状态变量balanceOf的函数
func (mc *Mycoin) _setBalanceOf(k types.Address, v bn.Number) {
	mc.sdk.Helper().StateHelper().Set(fmt.Sprintf("/balanceOf/%v", k), &amp;v)
}

//从状态数据库中删除状态变量balanceOf的键值的函数
func (mc *Mycoin) _delBalanceOf(k types.Address) {
	mc.sdk.Helper().StateHelper().Delete(fmt.Sprintf("/balanceOf/%v", k))
} 
</pre><p>&nbsp;</p><h3><a name='header-n286' class='md-header-anchor '></a>4.3.7 public:store:cache</h3><p>标记<code>public:store:cache</code>用于标识一个可缓存在内存的状态变量，状态变量必须是通过标记<code>contract</code>标注的合约类的成员变量。</p><p>标记<code>public:store:cache</code>之后的有效代码必须紧跟一个成员变量的定义。</p><p>标记<code>public:store:cache</code>为可选标记，在合约类定义中可以出现多次，每次标识一个状态变量。</p><p>标记<code>public:store:cache</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n291" mdtype="fences">&lt;public:store:cache标记语法&gt; ::= "//@:public:store:cache"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n293" mdtype="fences">//@:contract:mycoin
type Mycoin struct {
	sdk sdk.ISmartContract
	...
	//@:public:store:cache
	totalSupply bn.Number
}
</pre><p>可缓存的状态变量在合约代码中不能直接访问，根据BCBChain合约规范，BCBChain提供的SDK配套工具会自动生成访问该状态变量的读写函数，示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n295" mdtype="fences" style="break-inside: unset;">//读取状态变量totalSupply的函数
func (mc *Mycoin) _totalSupply() bn.Number {
	return *mc.sdk.Helper().StateHelper().McGetEx(
	    "/totalSupply", &amp;bn.Number{V: big.NewInt(0)}).(*bn.Number)
}

//检测状态数据totalSupply是否存在的函数
func (mc *Mycoin) _chkTotalSupply() bool {
	return mc.sdk.Helper().StateHelper().McCheck("/totalSupply")
}

//设置状态变量totalSupply的函数
func (mc *Mycoin) _setTotalSupply(v bn.Number) {
	mc.sdk.Helper().StateHelper().McSet("/totalSupply", &amp;v)
}

//清除状态变量totalSupply的内存缓存的函数
func (mc *Mycoin) _clrTotalSupply() {
	mc.sdk.Helper().StateHelper().McClear("/totalSupply")
}

//从状态数据库中删除状态变量totalSupply
func (m *Mycoin) _delTotalSupply() {
	m.sdk.Helper().StateHelper().McDelete("/totalSupply")
} 
</pre><p>&nbsp;</p><h3><a name='header-n297' class='md-header-anchor '></a>4.3.8 public:receipt</h3><p>标记<code>public:receipt</code>用于标识合约中所有收据的定义。</p><p>标记<code>public:receipt</code>之后的有效代码必须紧跟一个名为<code>receipt</code>的接口定义。</p><p>标记<code>public:receipt</code>为可选标记，在整个合约代码中最多只能出现一次。</p><p>标记<code>public:receipt</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n302" mdtype="fences">&lt;public:receipt标记语法&gt; ::= "//@:public:receipt"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n304" mdtype="fences">//@:public:receipt
type receipt interface {
	emitTransferMyCoin(token, from, to types.Address, value bn.Number)
}
</pre><p>接口<code>receipt</code>之中定义的每一个发送收据的方法必须以<code>emit</code>开头。<code>emit</code>之后的第一个单词首字母转为小写后就是这个收据的名称，可以根据收据名称到BCBChain链上进行检索。根据BCBChain合约规范，BCBChain提供的SDK配套工具会自动生成发送收据函数的实现代码，示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n306" mdtype="fences" style="break-inside: unset;">//下面的函数是由配套工具自动生成的
func (mc *Mycoin) emitTransferMyCoin(token, from, to types.Address, value bn.Number) {
	type transferMyCoin struct {
		Token types.Address `json:"token"`
		From types.Address `json:"from"`
		To types.Address `json:"to"`
		Value bn.Number `json:"value"`
	}
	mc.sdk.Helper().ReceiptHelper().Emit(
	    transferMycoin{
		    Token:   token,
		    From:    from,
		    To:      to,
		    Value:   value,
	    })
}

//下面是发送收据的示例代码，位于Transfer函数的实现当中
func (mc *Mycoin) Transfer(to types.Address, value bn.Number) {

	//实现转账的业务逻辑代码
	...

	//发送转账收据
	mc.emitTransferMyCoin(
		mc.sdk.Message().Contract().Address(),
		sender,
		to,
		value)
}
</pre><p>&nbsp;</p><h3><a name='header-n308' class='md-header-anchor '></a>4.3.9 public:method</h3><p>标记<code>public:method</code>用于标识合约的公开方法。</p><p>标记<code>public:method</code>之后的有效代码必须紧跟一个针对通过标记<code>contract</code>标注的合约类的成员函数定义（函数名称必须由大写字母开头），这个合约的成员函数可以通过BCBChain链的广播交易来执行。</p><p>标记<code>public:method</code>为可选标记，在整个合约代码中可以出现零次、一次或多次。</p><p>标记<code>public:method</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n313" mdtype="fences">&lt;public:method标记语法&gt; ::= "//@:public:method:gas[" &lt;燃料数量&gt; "]"
&lt;燃料数量&gt; ::= ["-"] &lt;十进制数&gt;
&lt;十进制数&gt; ::= &lt;十进制数字&gt; | &lt;十进制数&gt; &lt;十进制数字&gt;
&lt;十进制数字&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
</pre><p>注：</p><ul><li>燃料数量为正整数表示该方法调用消耗的燃料费用由交易最初的发起者支付；</li><li>燃料数量为0表示不需要支付手续费；</li><li>燃料数量为负整数表示该方法调用消耗的燃料费用由当前智能合约的账户进行支付。</li></ul><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n323" mdtype="fences">//@:public:method:gas[500]
func (mc *Mycoin) Transfer(to types.Address, value bn.Number) {
	...
}
</pre><p>&nbsp;</p><h3><a name='header-n325' class='md-header-anchor '></a>4.3.10 public:interface</h3><p>标记<code>public:interface</code>用于标识合约的公开接口。</p><p>标记<code>public:interface</code>之后的有效代码必须紧跟一个针对通过标记<code>contract</code>标注的合约类的成员函数定义（函数名称必须由大写字母开头），这个合约的成员函数可以从别的合约通过跨合约调用机制来执行。</p><p>标记<code>public:interface</code>为可选标记，在整个合约代码中可以出现零次、一次或多次。</p><p>标记<code>public:interface</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n330" mdtype="fences">&lt;public:interface标记语法&gt; ::= "//@:public:interface:gas[" &lt;燃料数量&gt; "]"
&lt;燃料数量&gt; ::= &lt;十进制数&gt;
&lt;十进制数&gt; ::= &lt;十进制数字&gt; | &lt;十进制数&gt; &lt;十进制数字&gt;
&lt;十进制数字&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n332" mdtype="fences">//@:public:interface:gas[450]
func (mc *Mycoin) Transfer(to types.Address, value bn.Number) {
	...
}
</pre><p>注：</p><ul><li>燃料数量大于等于0。</li></ul><p>标记<code>public:interface</code>标记<code>public:method</code>可以同时标注合约类的同一个成员函数，上面的例子实际上应该定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n338" mdtype="fences">//@:public:method:gas[500]
//@:public:interface:gas[450]
func (mc *Mycoin) Transfer(to types.Address, value bn.Number) {
	...
}
</pre><p>&nbsp;</p><h3><a name='header-n340' class='md-header-anchor '></a>4.3.11 public:mine</h3><p>标记<code>public:mine</code>用于标识合约公开的挖矿接口。</p><p>标记<code>public:mine</code>之后的有效代码必须紧跟一个针对通过标记<code>contract</code>标注的合约类的成员函数定义（挖矿函数原型必须为：<code>func Mine() int64</code>），这个挖矿函数将在 BCBChain 的区块达成共识后自动执行。</p><p>标记<code>public:mine</code>为可选标记，在整个合约代码中可以出现零次或一次。只有 BCBChain 的基础组织的智能合约才允许包含挖矿接口。</p><p>标记<code>public:mine</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n345" mdtype="fences">&lt;public:interface标记语法&gt; ::= "//@:public:mine"
</pre><p>示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n347" mdtype="fences">//@:public:mine
func (mc *Mycoin) Mine() int64 {
	...
}
</pre><p>注：</p><ul><li>挖矿函数 <code>Mine()</code> 只能与标记 <code>public:mine</code>  进行配合。</li></ul><p>&nbsp;</p><h3><a name='header-n354' class='md-header-anchor '></a>4.3.12 import</h3><p>标记<code>import</code>用于导入一个外部合约的接口原型，方便在当前合约中调用外部合约。</p><p>标记<code>import</code>为可选标记，在整个合约代码中可以出现多次，每次导入一个外部合约的跨合约调用接口，每一个外部合约只能导入一次。</p><p>标记<code>import</code>的BNF范式定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n358" mdtype="fences">&lt;import标记语法&gt; ::= "//@:import:" &lt;合约名称&gt;
&lt;合约名称&gt; ::= &lt;字母&gt; | &lt;合约名称&gt; &lt;字母数字串&gt;
&lt;字母数字串&gt; ::= &lt;字母&gt; | &lt;十进制数字&gt; | &lt;字母数字串&gt; &lt;字母&gt; | &lt;字母数字串&gt; &lt;十进制数字&gt; 
&lt;字母&gt; ::= "_" | "-" | "." | &lt;小写字母&gt; | &lt;大写字母&gt; 
&lt;小写字母&gt; ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | 
              "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | 
              "y" | "z" 
&lt;大写字母&gt; ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | 
              "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | 
              "Y" | "Z" 
&lt;十进制数字&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
</pre><p>以前面的<code>mycoin</code>代币合约为例，如果在其它合约中需要调用该合约，需要编写如下代码：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n360" mdtype="fences">//本段代码在合约mycontract中

//@:import:mycoin
type mycoin interface {
	Transfer(to types.Address, value bn.Number)
}
</pre><p>外部合约的接口名称自定义，只要遵循golang语法规范即可。</p><p>外部合约的接口在合约代码中不能直接访问，根据BCBChain合约规范，BCBChain提供的SDK配套工具会自动生成访问该外部合约接口的实现函数，自动生成的代码示例如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n363" mdtype="fences" style="break-inside: unset;">//本段代码是由SDK配套工具自动生成的

//mycoin This is method of MyContract 
func (m *MyContract) mycoin() *InterfacemycoinStub {
	return &amp;InterfacemycoinStub{}
}

//Transfer This is a method of InterfacemycoinStub
func (is *InterfacemycoinStub) Transfer(to types.Address, value bn.Number) {
	return
}

//run Transfer some receipts to destination contract
func (is *InterfacemycoinStub) run(f func()) (*InterfacemycoinStub) {
	...
	f()
	...
	return is
}

//contract Wrap the destination contract information
func (is *InterfacemycoinStub) contract() IContract {
	...
	return contract
}
</pre><p>下面是在合约代码中调用外部合约的示例代码：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n365" mdtype="fences">//本段代码在合约mycontract中

func (m *MyContract)TransferTest(to types.Address, value bn.Number) {
	m.mycoin().Transfer(to, value)
}
</pre><p>跨合约调用还支持向被调用合约传递收据，以下为示例代码（从合约 contract2 中调用合约 contract1 的接口）：</p><blockquote><p>合约1，提供跨合约接口服务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n369" mdtype="fences" style="break-inside: unset;">//@:contract:contract1
type C1 struct {
sdk sdk.ISmartContract
...
}

//@:public:interface:gas[450]
func (c *C1) Register() {

//I need receipt from caller
transfers := dw.sdk.Message().GetTransferToMe()
sdk.Require(transfers!=nil &amp;&amp; len(transfers)==1,
 types.ErrInvalidParameter, "Please transfer to me first")

token := transfers[0].Token
value := transfers[0].Value

...
}
</pre><p>合约2，跨合约调用者：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n371" mdtype="fences" style="break-inside: unset;">//@:contract:contract2
type C2 struct {
sdk sdk.ISmartContract
...
}

//@:import:contract1
type mycoin interface {
	Register()
}

//@:public:method:gas[450]
func (c *C2) Register() {
...
c.contract1().run(func(){
 c.sdk.Message().Contract().Account.TransferByName(
   "bcb",
   c.contract1().contract().Account().Address(),
   bn.N(1000000000),
 )
}).Register()
...
}
</pre></blockquote><p>&nbsp;</p><h2><a name='header-n373' class='md-header-anchor '></a>4.4 合约规范</h2><h3><a name='header-n374' class='md-header-anchor '></a>4.4.1 BNF范式定义</h3><p>综合上面对合约标记的描述，下面定义合约规范的BNF范式：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n376" mdtype="fences" style="break-inside: unset;">&lt;智能合约&gt; ::= &lt;合约定义代码文件&gt; {&lt;合约实现代码文件&gt;} {&lt;合约测试代码文件&gt;}

&lt;合约定义代码文件&gt; ::= &lt;代码包定义&gt; &lt;合约定义代码&gt;
&lt;合约实现代码文件&gt; ::= &lt;代码包定义&gt; &lt;合约实现代码&gt;
&lt;合约测试代码文件&gt; ::= &lt;代码包定义&gt; &lt;合约测试代码&gt;
&lt;代码包定义&gt; ::= "package" &lt;合约包名&gt;
&lt;合约包名&gt; ::= 遵循glang语法规范，但不能为 std
&lt;合约定义代码&gt; ::= "import ("
                     &lt;合约SDK包根路径&gt;
                     {[包别名] &lt;合约支撑代码包路径&gt;}
                 ")"
				 &lt;合约类定义&gt;
                 [&lt;合约上链初始化函数定义&gt;]
                 [&lt;挖矿定义&gt;]
                 [&lt;合约收据定义&gt;]
                 {&lt;跨合约调用接口定义&gt;}
                 {&lt;合约公开函数定义&gt;}
                 {&lt;合约实现代码&gt;}
&lt;合约SDK包根路径&gt; ::= double_quote "blockchain/smcsdk/sdk" double_quote
&lt;合约支撑代码包路径&gt; ::= 遵循golang代码包路径规范，遵循BCBChain合约规范的白名单与灰名单规范
&lt;包别名&gt; ::= 遵循golang代码规范的代码包别名，不允许使用 '.'
&lt;合约实现代码&gt; ::= 遵循golang代码规范的合约实现代码（不需要BCBChain合约标记的代码），包括类型定义、
                 常量定义、函数定义（注：不能包含全局变量定义，不允许使用 for 关键字，不允许递归
                 调用）
&lt;合约测试代码&gt; ::= 遵循golang单元测试规范的测试代码

&lt;合约类定义&gt; ::= "//@:contract:" &lt;合约名称&gt;
               "//@:version:" &lt;合约版本&gt;
               "//@:organization:" &lt;组织ID&gt;
               "//@:author:" &lt;账户公钥&gt;
               "type " &lt;合约类名&gt; " struct {"
               "    sdk sdk.ISmartContract"
                   {&lt;状态变量定义&gt;}
				   {&lt;golang变量定义&gt;}
               "}"
&lt;合约名称&gt; ::= 参见&lt;合约标记:contract&gt;
&lt;合约版本&gt; ::= 参见&lt;合约标记:version&gt;
&lt;组织ID&gt; ::= 参见&lt;合约标记:organization&gt;
&lt;账户公钥&gt; ::= 参见&lt;合约标记:author&gt;
&lt;合约类名&gt; ::= &lt;大写字母开头的标识符&gt;
&lt;golang变量定义&gt; ::= 遵循golang代码规范的标准变量定义代码
&lt;状态变量定义&gt; ::= &lt;基本状态变量定义&gt; | &lt;带缓存的状态变量定义&gt;
&lt;基本状态变量定义&gt; ::= "//@:public:store"
                   	 &lt;变量名称&gt; ["*"] &lt;变量类型&gt;
&lt;带缓存的状态变量定义&gt; ::= "//@:public:store:cache"
                   	    &lt;变量名称&gt; ["*"] &lt;变量类型&gt;
&lt;变量名称&gt; ::= &lt;标识符&gt;
&lt;变量类型&gt; ::= &lt;元数据类型&gt; | &lt;数组类型&gt; | &lt;映射表类型&gt;

&lt;合约上链初始化函数定义&gt; ::= &lt;部署函数&gt; | &lt;升级函数&gt;
&lt;部署函数&gt; ::= "//@:constructor"
              "func (" &lt;合约对象定义&gt; ") InitChain() {"
                &lt;上链代码&gt;
              "}"
&lt;升级函数&gt; ::= "//@:constructor"
              "func (" &lt;合约对象定义&gt; ") UpdateChain() {"
                &lt;上链代码&gt;
              "}"
&lt;挖矿定义&gt; ::= "//@:public:mine"
              "func (" &lt;合约对象定义&gt; ") Mine() int64 {"
                &lt;挖矿代码&gt;
              "}"
&lt;合约对象定义&gt; ::= &lt;变量名称&gt; "*" &lt;合约类名&gt;
&lt;上链代码&gt; ::= &lt;golang函数体&gt;
              注1：只允许访问状态变量
              注2：sdk中不允许访问Message()和Tx()
&lt;挖矿代码&gt; ::= &lt;golang函数体&gt;
              注1：sdk中不允许访问Message()和Tx()
&lt;golang函数体&gt; ::= 遵循golang代码规范的函数体实现代码，参见 &lt;合约实现代码&gt; 的定义

&lt;合约收据定义&gt; ::= "//@:public:receipt"
                 "type receipt interface {"
                     &lt;收据函数名称&gt; &lt;函数入口参数定义&gt;
                 "}"
&lt;收据函数名称&gt; ::= "emit" &lt;大写字母开头的标识符&gt;
&lt;函数入口参数定义&gt; ::= "(" &lt;参数表&gt; ")"
&lt;参数表&gt; ::= &lt;参数定义&gt; | &lt;参数表&gt; "," &lt;参数定义&gt;
&lt;参数定义&gt; ::= &lt;变量名称&gt; ["*"] &lt;变量类型&gt;

&lt;跨合约调用接口定义&gt; ::= "//@:import:" &lt;合约名称&gt;
                      "type "&lt;接口类名称&gt;" interface {"
                      	   &lt;接口函数名称&gt; &lt;函数入口参数定义&gt; &lt;函数返回定义&gt;
                      "}"
&lt;接口类名称&gt; ::= &lt;大写字母开头的标识符&gt;
&lt;接口函数名称&gt; ::= &lt;大写字母开头的标识符&gt;
&lt;函数返回定义&gt; ::= &lt;空&gt; | ["*"] &lt;变量类型&gt; | "(" &lt;返回表&gt; ")"
&lt;空&gt; ::= 空白
&lt;返回表&gt; ::= &lt;返回定义&gt; | &lt;返回表&gt; "," &lt;返回定义&gt;
&lt;返回定义&gt; ::= [&lt;变量名称&gt;] ["*"] &lt;变量类型&gt;

&lt;合约公开函数定义&gt; ::=[&lt;合约公开方法标记&gt;]
                   [&lt;合约公开接口标记&gt;]
                "func (" &lt;合约对象定义&gt; ")" &lt;公开函数名称&gt; &lt;函数入口参数定义&gt; &lt;函数返回定义&gt; "{"
                     &lt;golang函数体&gt;
                "}"                    
&lt;合约公开方法标记&gt; ::= "//@:public:method:gas[ "&lt;燃料数量&gt; "]"
&lt;合约公开接口标记&gt; ::= "//@:public:interface:gas[ "&lt;燃料数量&gt; "]"
&lt;燃料数量&gt; ::= 参见&lt;合约标记:public:method&gt;
&lt;公开函数名称&gt; ::= &lt;大写字母开头的标识符&gt;

&lt;标识符&gt; ::= &lt;字母&gt; | &lt;标识符&gt; &lt;字母数字串&gt;
&lt;大写字母开头的标识符&gt; ::= &lt;大写字母&gt; | &lt;大写字母开头的标识符&gt; &lt;字母数字串&gt;
&lt;字母数字串&gt; ::= &lt;字母&gt; | &lt;十进制数字&gt; | &lt;字母数字串&gt; &lt;字母&gt; | &lt;字母数字串&gt; &lt;十进制数字&gt; 
&lt;字母&gt; ::= "_" | &lt;小写字母&gt; | &lt;大写字母&gt; 
&lt;小写字母&gt; ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | 
              "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | 
              "y" | "z" 
&lt;大写字母&gt; ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | 
              "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | 
              "Y" | "Z" 
&lt;十进制数字&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | 8 | "9"
&lt;十进制数&gt; ::= &lt;十进制数字&gt; | &lt;十进制数&gt; &lt;十进制数字&gt;

&lt;元数据类型&gt; := &lt;golang内置类型&gt; | &lt;SDK内置类型&gt; | &lt;自定义数据结构&gt;
&lt;golang内置类型&gt; ::= "int" | "int8" | "int16" | "int32" | "int64" |
                    "uint" | "uint8" | "uint16" | "uint32" | "uint64" |
                    "bool" | "string" | "byte"
&lt;SDK内置类型&gt; ::= &lt;Address&gt; | &lt;HexBytes&gt; | &lt;Hash&gt; | &lt;PubKey&gt; | &lt;Number&gt;
&lt;Address&gt; ::= "types.Address"
&lt;HexBytes&gt; ::= "types.HexBytes"
&lt;Hash&gt; ::= "types.Hash"
&lt;PubKey&gt; ::= "types.PubKey"
&lt;Number&gt; ::= "bn.Number"
&lt;自定义数据结构&gt; ::= "type " &lt;标识符&gt; " struct {"
                      {&lt;变量名称&gt; ["*"] &lt;变量类型&gt;}
                  "}"
&lt;数组类型&gt; ::= &lt;数组维度定义&gt; [&lt;数组维度定义&gt;] &lt;元数据类型&gt;
&lt;数组维度定义&gt; ::= "[" [&lt;十进制数&gt;] "]"
&lt;映射表类型&gt; ::= &lt;映射表类型1&gt; | &lt;映射表类型2&gt;
&lt;映射表类型1&gt; ::= &lt;映射表定义&gt; [&lt;映射表定义&gt;] &lt;元数据类型&gt;
&lt;映射表类型2&gt; ::= &lt;映射表定义&gt; [&lt;映射表定义&gt;] &lt;数组类型&gt;
&lt;映射表定义&gt; ::= "map[" &lt;元数据类型&gt; "]"
</pre><p>&nbsp;</p><h3><a name='header-n378' class='md-header-anchor '></a>4.4.2 包结构规范</h3><p>下面定义合约包结构的BNF范式：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n380" mdtype="fences">&lt;智能合约包结构&gt; ::= &lt;合约定义代码文件&gt; {&lt;合约实现代码文件&gt;} {&lt;合约测试代码文件&gt;}
&lt;合约定义代码文件&gt; ::= &lt;合约代码目录&gt; "/" &lt;golang实现代码文件名&gt;
&lt;合约实现代码文件&gt; ::= &lt;合约代码目录&gt; "/" &lt;golang实现代码文件名&gt;
&lt;合约测试代码文件&gt; ::= &lt;合约代码目录&gt; "/" &lt;golang测试代码文件名&gt;
&lt;合约代码目录&gt; ::= &lt;GOPATH&gt; "/" &lt;合约根目录&gt; "/" &lt;合约名称&gt; "/v" &lt;合约版本&gt; "/" &lt;合约名称&gt;
&lt;GOPATH&gt; ::= golang标准环境变量GOPATH指向的目录
&lt;合约根目录&gt; ::= "src/contract/" &lt;组织ID&gt; "/code"
&lt;组织ID&gt; ::= 参见&lt;合约标记:organization&gt;
&lt;golang实现代码文件名&gt; ::= &lt;合法文件名&gt; ".go"
&lt;golang测试代码文件名&gt; ::= &lt;合法文件名&gt; "_test.go"
&lt;任意文件名&gt; ::= &lt;合法文件名&gt;|&lt;非法文件名&gt;
&lt;非法文件名&gt; ::= [&lt;合法文件名&gt;] "autogen" [&lt;合法文件名&gt;] | &lt;任意文件名&gt; "_test"
&lt;合法文件名&gt; ::= 排除&lt;非法文件名&gt;以后所有操作系统认可作为文件名的字符串
</pre><p>注：规范定义中出现的空白符间隔仅为排版需要，不作为规范的一部分。</p><p>&nbsp;</p><h3><a name='header-n383' class='md-header-anchor '></a>4.4.3 白名单列表</h3><p>出于安全考虑，BCBChain智能合约限制为只允许导入行为明确且不会导致不同节点运行结果不一致的代码支撑包。这样的包包含在白名单列表中。</p><p>白名单列表中支持的代码包在智能合约中可以放心的使用。</p><p>白名单与灰名单的具体内容随智能合约SDK及配套的BCBChain插件版本升级将会有所不同，详细信息请参见智能合约SDK及配套的BCBChain插件的相关文件。</p><p>下面是第一版白名单列表：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n388" mdtype="fences" style="break-inside: unset;">//以下为可用的 golang 标识包
bytes
container/heap
container/list
container/ring
crypto
crypto/aes
crypto/cipher
crypto/des
crypto/hmac
crypto/md5
crypto/rc4
crypto/sha1
crypto/sha256
crypto/sha512
encoding
encoding/ascii85
encoding/asn1
encoding/base32
encoding/base64
encoding/binary
encoding/csv
encoding/gob
encoding/hex
encoding/json
encoding/pem
encoding/xml
errors
fmt
hash
hash/adler32
hash/crc32
hash/crc64
hash/fnv
index/suffixarray
math
math/big
math/bits
math/cmplx
reflect
regexp
regexp/syntax
sort
strconv
strings
unicode
unicode/utf16
unicode/utf8

//以下为 SDK 提供的标准包
blockchain/smcsdk/sdk
</pre><p>&nbsp;</p><div style="page-break-after: always;"></div><h2><a name='header-n391' class='md-header-anchor '></a>4.5 BRC20代币</h2><p>本指南第2.1.2节发布的智能合约“代币”是一个演示性的代币合约，不是符合BCBChain标准的BRC20代币。</p><p>BCBChain的用户可以自己编写智能合约发行符合BRC20代币规范的代币。本节定义符合BRC20代币规范的智能合约。</p><p>规范描述如下：</p><ul><li><p>合约必须明确调用智能合约SDK提供的接口<code>ITokenHelper::RegisterToken(...)</code>向BCBChain注册一个新的代币（每个智能合约能且只能注册一个代币）；</p></li><li><p>合约注册代币会自动在BCBChain上记录一条标准的代币生成收据，收据定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n400" mdtype="fences" style="break-inside: unset;">import (
    "blockchain/smcsdk/sdk/bn"
    "blockchain/smcsdk/sdk/types"
)

// Name of receipt: std::newToken
type NewToken struct {
    TokenAddress     types.Address `json:"tokenAddr"`     // 代币地址
    ContractAddress  types.Address `json:"contractAddr"`  // 代币的合约地址
    Owner            types.Address `json:"owner"`         // 代币拥有者的外部账户地址
    Name             string      `json:"name"`            // 代币名称
    Symbol           string      `json:"symbol"`          // 代币符号
    TotalSupply      bn.Number   `json:"totalSupply"`     // 代币总供应量（单位：cong）
    AddSupplyEnabled bool        `json:"addSupplyEnabled"`// 代币是否支持增发
    BurnEnabled      bool        `json:"burnEnabled"`     // 代币是否支持燃烧
    GasPrice         int64       `json:"gasPrice"`        // 代币燃料价格（单位：cong）
}
</pre></li><li><p>合约必须实现本章定义的方法与接口。</p></li></ul><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n405' class='md-header-anchor '></a>4.5.1 Transfer</h3><p><strong>方法原型</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n407" mdtype="fences">import (
    "blockchain/smcsdk/sdk/bn"
    "blockchain/smcsdk/sdk/types"
)

//@:public:method:gas[500]
//@:public:interface:gas[450]
Transfer(types.Address,bn.Number)
</pre><p><strong>功能说明</strong></p><ul><li>执行代币转移功能。</li></ul><p><strong>实现说明</strong></p><ul><li>必须实现；</li><li>必须标记为<code>public:method</code>；</li><li>必须标记为<code>public:interface</code>。</li></ul><p><strong>调用说明</strong></p><ul><li>允许任何人通过广播交易进行调用；</li><li>允许同组织的其它智能合约进行跨合约调用；</li><li>允许同组织的其它智能合约通过SDK提供的接口<code>IAccount::Transfer</code>直接调用（SDK底层自动进行跨合约调用）。</li></ul><p><strong>输入参数</strong></p><ul><li><p>_to<span>		</span>  types.Address<span>	</span>   代币接收方地址（可以是外部账户地址、合约账户地址、合约地址）</p><p>_value<span>	</span>bn.Number<span>			</span>转移的代币数额（单位：cong）</p><p>注：如果接收方地址是合约地址，会自动将接收到的代币转入该合约的账户地址。</p></li></ul><p><strong>输出收据</strong></p><ul><li><p>BRC20代币Transfer() 方法会自动在BCBChain上记录一条标准的代币转移收据，收据定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n438" mdtype="fences">import (
    "blockchain/smcsdk/sdk/bn"
    "blockchain/smcsdk/sdk/types"
)

// Name of receipt: std::transfer
type Transfer struct {
    Token      smc.Address  `json:"token"`      // 代币地址
    From       smc.Address  `json:"from"`       // 转出方地址
    To         smc.Address  `json:"to"`         // 代币接收方地址
    Value      bn.Number    `json:"value"`      // 转移的代币数额（（单位：cong）
}
</pre></li></ul><div style="page-break-after: always;"></div><h3><a name='header-n440' class='md-header-anchor '></a>4.5.2 AddSupply</h3><p><strong>方法原型</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n442" mdtype="fences">import (
    "blockchain/smcsdk/sdk/bn"
)

//@:public:method:gas[2400]
AddSupply(bn.Number)
</pre><p><strong>功能说明</strong></p><ul><li>为代币增加供应量。</li></ul><p><strong>实现说明</strong></p><ul><li>可选实现；</li><li>如果实现，必须标记为<code>public:method</code>。</li></ul><p><strong>调用说明</strong></p><ul><li>只有代币拥有者才能通过广播交易进行调用。</li></ul><p><strong>输入参数</strong></p><ul><li>_value<span>	</span>bn.Number<span>	</span>新增加的供应量（单位：cong）。</li></ul><p><strong>输出收据</strong></p><ul><li><p>BRC20代币AddSupply() 方法会自动在BCBChain上记录一条标准的代币增发收据，收据定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n465" mdtype="fences">import (
    "blockchain/smcsdk/sdk/bn"
    "blockchain/smcsdk/sdk/types"
)

// Name of receipt: std::addSupply
type AddSupply struct {
    Token       types.Address `json:"token"`       // 代币地址
    Value       bn.Number     `json:"value"`       // 增发的供应量（单位：cong）
    TotalSupply bn.Number     `json:"totalSupply"` // 新的总供应量（单位：cong）
}
</pre></li><li><p>BRC20代币AddSupply() 方法还会自动在BCBChain上记录一条标准的<code>std::transfer</code>收据。</p></li></ul><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n470' class='md-header-anchor '></a>4.5.3 Burn</h3><p><strong>方法原型</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n472" mdtype="fences">import (
    "blockchain/smcsdk/sdk/bn"
)

//@:public:method:gas[2400]
Burn(bn.Number)
</pre><p><strong>功能说明</strong></p><ul><li>燃烧代币的供应量。</li></ul><p><strong>实现说明</strong></p><ul><li>可选实现；</li><li>如果实现，必须标记为<code>public:method</code>。</li></ul><p><strong>调用说明</strong></p><ul><li>只有代币拥有者才能通过广播交易进行调用。</li></ul><p><strong>输入参数</strong></p><ul><li>_value<span>	</span>bn.Number<span>	</span>燃烧掉的供应量（单位：cong）。</li></ul><p><strong>输出收据</strong></p><ul><li><p>BRC20代币Burn() 方法会自动在BCBChain上记录一条标准的代币燃烧收据，收据定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n495" mdtype="fences">import (
    "blockchain/smcsdk/sdk/bn"
    "blockchain/smcsdk/sdk/types"
)

// Name of receipt: std::burn
type Burn struct {
    Token       types.Address `json:"token"`       // 代币地址
    Value       bn.Number     `json:"value"`       // 燃烧的供应量（单位：cong）
    TotalSupply bn.Number     `json:"totalSupply"` // 新的总供应量（单位：cong）
}
</pre></li><li><p>BRC20代币Burn() 方法还会自动在BCBChain上记录一条标准的<code>std::transfer</code>收据。</p></li></ul><p>&nbsp;</p><div style="page-break-after: always;"></div><h3><a name='header-n500' class='md-header-anchor '></a>4.5.4 SetGasPrice</h3><p><strong>方法原型</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n502" mdtype="fences">//@:public:method:gas[2400]
SetGasPrice(int64)
</pre><p><strong>功能说明</strong></p><ul><li>设置燃料价格。</li></ul><p><strong>实现说明</strong></p><ul><li>可选实现；</li><li>如果实现，必须标记为<code>public:method</code>。</li></ul><p><strong>调用说明</strong></p><ul><li>只有代币拥有者才能通过广播交易进行调用。</li></ul><p><strong>输入参数</strong></p><ul><li>_value<span>	</span>int64<span>		</span>新的燃料价格（单位：cong）。</li></ul><p><strong>输出收据</strong></p><ul><li><p>BRC20代币SetGasPrice() 方法会自动在BCBChain上记录一条标准的设置燃料价格收据，收据定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n525" mdtype="fences">import (
    "blockchain/smcsdk/sdk/types"
)

// Name of receipt: std::setGasPrice
type SetGasPrice struct {
    Token    types.Address `json:"token"`    // 代币地址
    GasPrice int64         `json:"gasPrice"` // 燃料价格（单位：cong）
}
</pre></li></ul><div style="page-break-after: always;"></div><h3><a name='header-n527' class='md-header-anchor '></a>4.5.6 SetOwner</h3><p><strong>方法原型</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n529" mdtype="fences">import (
    "blockchain/smcsdk/sdk/types"
)

//@:public:method:gas[2400]
SetOwner(types.Address)
</pre><p><strong>功能说明</strong></p><ul><li>转移智能合约及代币的所有权。</li></ul><p><strong>实现说明</strong></p><ul><li>可选实现；</li><li>如果实现，必须标记为<code>public:method</code>。</li></ul><p><strong>调用说明</strong></p><ul><li>只有代币拥有者才能通过广播交易进行调用。</li></ul><p><strong>输入参数</strong></p><ul><li>_newOwner<span>	</span>types.Address<span>	</span>合约新的拥有者的外部账户地址。</li></ul><p><strong>输出收据</strong></p><ul><li><p>BRC20代币SetOwner() 方法会自动在BCBChain上记录一条标准的转移所有权收据，收据定义如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n552" mdtype="fences">import (
    "blockchain/smcsdk/sdk/types"
)

// Name of receipt: std::setOwner
type SetOwner struct {
    ContractAddr types.Address `json:"contractAddr"` // 智能合约地址
    NewOwner     types.Address `json:"newOwner"`     // 合约新的拥有者的外部账户地址
}
</pre></li><li><p>BRC20代币SetOwner() 方法还会自动在BCBChain上记录一条标准的<code>std::transfer</code>收据。</p></li></ul><p>&nbsp;</p><div style="page-break-after: always;"></div><h1><a name='header-n557' class='md-header-anchor '></a>5 开发智能合约</h1><p>准备开发环境、开发、测试及部署智能合约的详细指令参见文档《BCBChain_V2.0_Quick_Start》。</p><p>&nbsp;</p></div>
</body>
</html>